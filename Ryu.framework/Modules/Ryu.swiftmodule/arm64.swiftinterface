// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Ryu
import AVFoundation
import AdSupport
import Amplitude
import AppsFlyerLib
import ChainUtils
import CommonCrypto
import ContactsUI
import CoreFoundation
import CoreLocation
import Dispatch
import FBSDKCoreKit
import Foundation
import GameAnalytics
import GameKit
import LocalAuthentication
import Lottie
import MessageUI
import NetworkUtils
import PassKit
import PhoneNumberKit
import QuartzCore
@_exported import Ryu
import SafariServices
import Security
import StoreKit
import Swift
import SwiftPromises
import UIKit
import UserNotifications
import WebKit
import zlib
public enum SocketIOClientOption {
  case compress
  case connectParams([Swift.String : Any])
  case cookies([Foundation.HTTPCookie])
  case extraHeaders([Swift.String : Swift.String])
  case forceNew(Swift.Bool)
  case forcePolling(Swift.Bool)
  case forceWebsockets(Swift.Bool)
  case handleQueue(Dispatch.DispatchQueue)
  case log(Swift.Bool)
  case logger(Ryu.SocketLogger)
  case path(Swift.String)
  case reconnects(Swift.Bool)
  case reconnectAttempts(Swift.Int)
  case reconnectWait(Swift.Int)
  case reconnectWaitMax(Swift.Int)
  case randomizationFactor(Swift.Double)
  case secure(Swift.Bool)
  case security(Ryu.SSLSecurity)
  case selfSigned(Swift.Bool)
  case sessionDelegate(Foundation.URLSessionDelegate)
  public var description: Swift.String {
    get
  }
  public static func == (lhs: Ryu.SocketIOClientOption, rhs: Ryu.SocketIOClientOption) -> Swift.Bool
}
@objc public enum SocketIOStatus : Swift.Int, Swift.CustomStringConvertible {
  case notConnected
  case disconnected
  case connecting
  case connected
  public var active: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct SocketIOClientConfiguration : Swift.ExpressibleByArrayLiteral, Swift.Collection, Swift.MutableCollection {
  public typealias Element = Ryu.SocketIOClientOption
  public typealias Index = Swift.Array<Ryu.SocketIOClientOption>.Index
  public typealias Iterator = Swift.Array<Ryu.SocketIOClientOption>.Iterator
  public typealias SubSequence = Swift.Array<Ryu.SocketIOClientOption>.SubSequence
  public var startIndex: Ryu.SocketIOClientConfiguration.Index {
    get
  }
  public var endIndex: Ryu.SocketIOClientConfiguration.Index {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: Ryu.SocketIOClientConfiguration.Index.Stride {
    get
  }
  public var first: Ryu.SocketIOClientConfiguration.Element? {
    get
  }
  public subscript(position: Ryu.SocketIOClientConfiguration.Index) -> Ryu.SocketIOClientConfiguration.Element {
    get
    set
  }
  public subscript(bounds: Swift.Range<Ryu.SocketIOClientConfiguration.Index>) -> Ryu.SocketIOClientConfiguration.SubSequence {
    get
    set
  }
  public init(arrayLiteral elements: Ryu.SocketIOClientConfiguration.Element...)
  public func makeIterator() -> Ryu.SocketIOClientConfiguration.Iterator
  public func index(after i: Ryu.SocketIOClientConfiguration.Index) -> Ryu.SocketIOClientConfiguration.Index
  public mutating func insert(_ element: Ryu.SocketIOClientConfiguration.Element, replacing replace: Swift.Bool = true)
  public typealias ArrayLiteralElement = Ryu.SocketIOClientConfiguration.Element
  public typealias Indices = Swift.DefaultIndices<Ryu.SocketIOClientConfiguration>
}
public protocol ConfigSettable {
  mutating func setConfigs(_ config: Ryu.SocketIOClientConfiguration)
}
public let demo1Username: Swift.String
public var demo1ProfileImage: UIKit.UIImage {
  get
}
public protocol SocketData {
  func socketRepresentation() throws -> Ryu.SocketData
}
extension SocketData {
  public func socketRepresentation() -> Ryu.SocketData
}
extension Array : Ryu.SocketData {
}
extension Bool : Ryu.SocketData {
}
extension Dictionary : Ryu.SocketData {
}
extension Double : Ryu.SocketData {
}
extension Int : Ryu.SocketData {
}
extension NSArray : Ryu.SocketData {
}
extension Data : Ryu.SocketData {
}
extension NSData : Ryu.SocketData {
}
extension NSDictionary : Ryu.SocketData {
}
extension NSString : Ryu.SocketData {
}
extension NSNull : Ryu.SocketData {
}
extension String : Ryu.SocketData {
}
public typealias AckCallback = ([Any]) -> ()
public typealias NormalCallback = ([Any], Ryu.SocketAckEmitter) -> ()
public typealias Post = (msg: Swift.String, completion: (() -> ())?)
@objc final public class SocketAckEmitter : ObjectiveC.NSObject {
  @objc final public var rawEmitView: Ryu.SocketRawAckView {
    @objc get
  }
  final public var expected: Swift.Bool {
    get
  }
  public init(socket: Ryu.SocketIOClient, ackNum: Swift.Int)
  final public func with(_ items: Ryu.SocketData...)
  @objc final public func with(_ items: [Any])
  @objc deinit
  @objc override dynamic public init()
}
@objc @_hasMissingDesignatedInitializers final public class OnAckCallback : ObjectiveC.NSObject {
  @objc deinit
  @objc final public func timingOut(after seconds: Swift.Double, callback: @escaping Ryu.AckCallback)
  @objc override dynamic public init()
}
@objc open class SocketIOClient : ObjectiveC.NSObject, Ryu.SocketIOClientSpec {
  @objc final public let nsp: Swift.String
  @objc public var sid: Swift.String {
    @objc get
  }
  public var anyHandler: ((Ryu.SocketAnyEvent) -> ())? {
    get
  }
  public var handlers: [Ryu.SocketEventHandler] {
    get
  }
  @objc weak public var manager: Ryu.SocketManagerSpec? {
    get
  }
  @objc public var rawEmitView: Ryu.SocketRawView {
    @objc get
  }
  @objc public var status: Ryu.SocketIOStatus {
    @objc get
  }
  @objc public init(manager: Ryu.SocketManagerSpec, nsp: Swift.String)
  @objc deinit
  @objc open func connect()
  @objc open func connect(timeoutAfter: Swift.Double, withHandler handler: (() -> ())?)
  open func didConnect(toNamespace namespace: Swift.String)
  open func didDisconnect(reason: Swift.String)
  @objc open func disconnect()
  open func emit(_ event: Swift.String, _ items: Ryu.SocketData..., completion: (() -> ())? = nil)
  @objc open func emit(_ event: Swift.String, with items: [Any])
  @objc open func emit(_ event: Swift.String, with items: [Any], completion: (() -> ())? = nil)
  open func emitWithAck(_ event: Swift.String, _ items: Ryu.SocketData...) -> Ryu.OnAckCallback
  @objc open func emitWithAck(_ event: Swift.String, with items: [Any]) -> Ryu.OnAckCallback
  open func emitAck(_ ack: Swift.Int, with items: [Any])
  @objc open func handleAck(_ ack: Swift.Int, data: [Any])
  open func handleClientEvent(_ event: Ryu.SocketClientEvent, data: [Any])
  @objc open func handleEvent(_ event: Swift.String, data: [Any], isInternalMessage: Swift.Bool, withAck ack: Swift.Int = -1)
  open func handlePacket(_ packet: Ryu.SocketPacket)
  @objc open func leaveNamespace()
  @objc open func joinNamespace()
  open func off(clientEvent event: Ryu.SocketClientEvent)
  @objc open func off(_ event: Swift.String)
  @objc open func off(id: Foundation.UUID)
  @discardableResult
  @objc open func on(_ event: Swift.String, callback: @escaping Ryu.NormalCallback) -> Foundation.UUID
  @discardableResult
  open func on(clientEvent event: Ryu.SocketClientEvent, callback: @escaping Ryu.NormalCallback) -> Foundation.UUID
  @discardableResult
  open func once(clientEvent event: Ryu.SocketClientEvent, callback: @escaping Ryu.NormalCallback) -> Foundation.UUID
  @discardableResult
  @objc open func once(_ event: Swift.String, callback: @escaping Ryu.NormalCallback) -> Foundation.UUID
  @objc open func onAny(_ handler: @escaping (Ryu.SocketAnyEvent) -> ())
  @available(*, unavailable, message: "Call the manager's reconnect method")
  @objc open func reconnect()
  @objc open func removeAllHandlers()
  @objc open func setReconnecting(reason: Swift.String)
  @objc override dynamic public init()
}
@objc public protocol SocketManagerSpec : AnyObject, Ryu.SocketEngineClient {
  @objc var defaultSocket: Ryu.SocketIOClient { get }
  @objc var engine: Ryu.SocketEngineSpec? { get set }
  @objc var forceNew: Swift.Bool { get set }
  @objc var handleQueue: Dispatch.DispatchQueue { get set }
  @objc var nsps: [Swift.String : Ryu.SocketIOClient] { get set }
  @objc var reconnects: Swift.Bool { get set }
  @objc var reconnectWait: Swift.Int { get set }
  @objc var reconnectWaitMax: Swift.Int { get set }
  @objc var randomizationFactor: Swift.Double { get set }
  @objc var socketURL: Foundation.URL { get }
  @objc var status: Ryu.SocketIOStatus { get }
  @objc func connect()
  @objc func connectSocket(_ socket: Ryu.SocketIOClient)
  @objc func didDisconnect(reason: Swift.String)
  @objc func disconnect()
  @objc func disconnectSocket(_ socket: Ryu.SocketIOClient)
  @objc func disconnectSocket(forNamespace nsp: Swift.String)
  @objc func emitAll(_ event: Swift.String, withItems items: [Any])
  @objc func reconnect()
  @objc @discardableResult
  func removeSocket(_ socket: Ryu.SocketIOClient) -> Ryu.SocketIOClient?
  @objc func socket(forNamespace nsp: Swift.String) -> Ryu.SocketIOClient
}
@_hasMissingDesignatedInitializers public class GameAnalyticsManager {
  public func addProgressionEvent(with progression: GameAnalytics.GAProgressionStatus, progression01: Swift.String, progression02: Swift.String?, progression03: Swift.String?)
  public func addDesignEvent(withEventId eventId: Swift.String, _ value: Foundation.NSNumber? = nil)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class RDCViewController : UIKit.UIViewController {
  @objc override final public func viewDidLoad()
  @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol SocketIOClientSpec : AnyObject {
  var anyHandler: ((Ryu.SocketAnyEvent) -> ())? { get }
  var handlers: [Ryu.SocketEventHandler] { get }
  var manager: Ryu.SocketManagerSpec? { get }
  var nsp: Swift.String { get }
  var rawEmitView: Ryu.SocketRawView { get }
  var status: Ryu.SocketIOStatus { get }
  func connect()
  func connect(timeoutAfter: Swift.Double, withHandler handler: (() -> ())?)
  func didConnect(toNamespace namespace: Swift.String)
  func didDisconnect(reason: Swift.String)
  func didError(reason: Swift.String)
  func disconnect()
  func emit(_ event: Swift.String, _ items: Ryu.SocketData..., completion: (() -> ())?)
  func emitAck(_ ack: Swift.Int, with items: [Any])
  func emitWithAck(_ event: Swift.String, _ items: Ryu.SocketData...) -> Ryu.OnAckCallback
  func handleAck(_ ack: Swift.Int, data: [Any])
  func handleClientEvent(_ event: Ryu.SocketClientEvent, data: [Any])
  func handleEvent(_ event: Swift.String, data: [Any], isInternalMessage: Swift.Bool, withAck ack: Swift.Int)
  func handlePacket(_ packet: Ryu.SocketPacket)
  func leaveNamespace()
  func joinNamespace()
  func off(clientEvent event: Ryu.SocketClientEvent)
  func off(_ event: Swift.String)
  func off(id: Foundation.UUID)
  func on(_ event: Swift.String, callback: @escaping Ryu.NormalCallback) -> Foundation.UUID
  func on(clientEvent event: Ryu.SocketClientEvent, callback: @escaping Ryu.NormalCallback) -> Foundation.UUID
  func once(clientEvent event: Ryu.SocketClientEvent, callback: @escaping Ryu.NormalCallback) -> Foundation.UUID
  func once(_ event: Swift.String, callback: @escaping Ryu.NormalCallback) -> Foundation.UUID
  func onAny(_ handler: @escaping (Ryu.SocketAnyEvent) -> ())
  func removeAllHandlers()
  func setReconnecting(reason: Swift.String)
}
extension SocketIOClientSpec {
  public func didError(reason: Swift.String)
}
public enum SocketClientEvent : Swift.String {
  case connect
  case disconnect
  case error
  case ping
  case pong
  case reconnect
  case reconnectAttempt
  case statusChange
  case websocketUpgrade
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
@objc public protocol SocketEngineSpec {
  @objc var client: Ryu.SocketEngineClient? { get set }
  @objc var closed: Swift.Bool { get }
  @objc var compress: Swift.Bool { get }
  @objc var connected: Swift.Bool { get }
  @objc var connectParams: [Swift.String : Any]? { get set }
  @objc var cookies: [Foundation.HTTPCookie]? { get }
  @objc var engineQueue: Dispatch.DispatchQueue { get }
  @objc var extraHeaders: [Swift.String : Swift.String]? { get set }
  @objc var fastUpgrade: Swift.Bool { get }
  @objc var forcePolling: Swift.Bool { get }
  @objc var forceWebsockets: Swift.Bool { get }
  @objc var polling: Swift.Bool { get }
  @objc var probing: Swift.Bool { get }
  @objc var sid: Swift.String { get }
  @objc var socketPath: Swift.String { get }
  @objc var urlPolling: Foundation.URL { get }
  @objc var urlWebSocket: Foundation.URL { get }
  @objc @available(*, deprecated, message: "No longer needed, if we're not polling, then we must be doing websockets")
  var websocket: Swift.Bool { get }
  @objc var ws: Ryu.WebSocket? { get }
  @objc init(client: Ryu.SocketEngineClient, url: Foundation.URL, options: [Swift.String : Any]?)
  @objc func connect()
  @objc func didError(reason: Swift.String)
  @objc func disconnect(reason: Swift.String)
  @objc func doFastUpgrade()
  @objc func flushWaitingForPostToWebSocket()
  @objc func parseEngineData(_ data: Foundation.Data)
  @objc func parseEngineMessage(_ message: Swift.String)
  @objc func write(_ msg: Swift.String, withType type: Ryu.SocketEnginePacketType, withData data: [Foundation.Data], completion: (() -> ())?)
}
public var rdcMatchId: Swift.String? {
  get
}
public var rdcIsOfflineMatch: Swift.Bool {
  get
}
public var rdcHighScoreForOfflineMatch: Swift.Int {
  get
}
public var rdcCurrentUser: Swift.String? {
  get
}
public var userProfilePicture: Swift.String {
  get
}
public var rdcCurrentGameMode: Swift.String {
  get
}
public enum RDCError : Swift.Error {
  case none
  case parsingError
  case invalidJSON
  case networkError
  case noUsernameError
  case invalidParams
  public static func == (a: Ryu.RDCError, b: Ryu.RDCError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public let rdcGameAnalyticsManager: Ryu.GameAnalyticsManager
public let rdcFacebookAnalyticsManager: Ryu.FacebookAnalyticsManager
public var rdcOrientationMask: UIKit.UIInterfaceOrientationMask
public let rdcLandscape: UIKit.UIInterfaceOrientationMask
public let rdcPortrait: UIKit.UIInterfaceOrientationMask
public let rdcAllButUpsideDown: UIKit.UIInterfaceOrientationMask
public let rdcAllOrientations: UIKit.UIInterfaceOrientationMask
public enum RDCBackgroundAnimation {
  case none
  case circles
  public static func == (a: Ryu.RDCBackgroundAnimation, b: Ryu.RDCBackgroundAnimation) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct RDCGradient : Swift.Decodable {
  public var direction: Ryu.RDCGradientDirection
  public var colors: [Swift.String]
  public init(direction: Ryu.RDCGradientDirection, colors: [Swift.String])
  public init(from decoder: Swift.Decoder) throws
}
public struct RDCBackground {
  public var gradient: Ryu.RDCGradient?
  public var solidBackground: Swift.String?
  public init(gradient: Ryu.RDCGradient)
  public init(solidBackground: Swift.String)
}
public enum SkipTutorialButtonPlacement {
  case topLeft, topRight, bottomLeft, bottomRight
  public static func == (a: Ryu.SkipTutorialButtonPlacement, b: Ryu.SkipTutorialButtonPlacement) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct AppsFlyerCredentials {
  public var appsFlyerDevKey: Swift.String
  public var appsFlyerAppleAppID: Swift.String
  public init(appsFlyerDevKey: Swift.String, appsFlyerAppleAppID: Swift.String)
}
public class RDCConfig {
  public var isDebug: Swift.Bool
  public var disableFriends: Swift.Bool
  public var isGameFriendsOnly: Swift.Bool
  public var regularFont: Swift.String?
  public var boldFont: Swift.String?
  public var italicizedFont: Swift.String?
  public var background: Ryu.RDCBackground
  public var backgroundAnimation: Ryu.RDCBackgroundAnimation
  public var backgroundImage: UIKit.UIImage?
  public var headerColor: Swift.String
  public var noGameTutorial: Swift.Bool?
  public var noCache: Swift.Bool?
  public var gameNeedsLandscape: Swift.Bool?
  public var offlineOptions: [Ryu.OfflineOption]
  public var loginButtonGradientColor: Swift.String?
  public var loadingCardColor: Swift.String?
  public var scoringUIView: UIKit.UIView?
  public var scoringRules: [(Swift.String, Swift.String?)]?
  public var orientation: UIKit.UIInterfaceOrientationMask
  public var gameAnalyticsGameKey: Swift.String?
  public var gameAnalyticsSecretKey: Swift.String?
  public var appsFlyerCredentials: Ryu.AppsFlyerCredentials?
  public var amplitudeAPIKey: Swift.String?
  public var hideOverlayOnFirstMatch: Swift.Bool?
  public var forceLogs: Swift.Bool
  public var menuBackgroundMusicTracks: [AVFoundation.AVAudioPlayer]?
  public var tabAndNavColor: Swift.String?
  public var unselectedTabItemTintColor: Swift.String?
  public var gameLogo: UIKit.UIImage?
  public var playButtonImage: UIKit.UIImage?
  public var mid: Swift.String?
  required public init(gameId: Swift.String, apiKey: Swift.String)
  @objc deinit
}
public func showRulesOnStartDemoMatch(_ viewController: UIKit.UIViewController)
public func addTutorialSkipButton(_ viewController: UIKit.UIViewController, withPlacement placement: Ryu.SkipTutorialButtonPlacement)
@available(*, unavailable, renamed: "rdcStart(_appdelegate:config:)", message: "rdcStart now requires the appdelegate as an argument")
public func rdcStart(config: Ryu.RDCConfig)
public func rdcStart(_ appdelegate: UserNotifications.UNUserNotificationCenterDelegate, config: Ryu.RDCConfig)
public func rdcDidBecomeActive()
public func rdcDidReceiveResponse(response: UserNotifications.UNNotificationResponse, completionHandler: @escaping () -> Swift.Void)
public func rdcStop()
public func rdcResume()
public func rdcStoreToken(deviceToken: Foundation.Data)
public func rdcSignInFromURL(_ url: Foundation.URL, _ delegate: UIKit.UIApplicationDelegate)
public func rdcSegueToRyu(_ viewController: UIKit.UIViewController)
public func rdcStartTimedGame(lengthOfGame: Swift.Double, interval: Swift.Double = 1.0, completion: @escaping (Swift.Double, Swift.Bool) -> ())
public func rdcPauseTimedGame()
public func rdcResumeTimedGame(completion: @escaping (Swift.Double, Swift.Bool) -> ())
public func rdcCachePut<T>(key: Swift.String = "", obj: T, matchId: Swift.String? = rdcMatchId, offline: Swift.Bool = false) -> Swift.Bool where T : Swift.Encodable
public func rdcCacheGet<T>(key: Swift.String = "", type: T.Type, matchId: Swift.String? = rdcMatchId, offline: Swift.Bool = false) -> T? where T : Swift.Decodable
public func rdcCacheDelete(key: Swift.String = "", matchId: Swift.String? = rdcMatchId, offline: Swift.Bool = false)
@objc public class RDCTurnBasedGame : ObjectiveC.NSObject, Swift.Codable {
  public var scores: [Swift.String : Swift.Int]
  public var currentPlayer: Swift.String
  public init(scores: [Swift.String : Swift.Int], currentPlayer: Swift.String)
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@objc public class RDCTimedGame : ObjectiveC.NSObject, Swift.Codable {
  public var timeRemaining: Swift.Double
  public var score: Swift.Int
  public init(timeRemaining: Swift.Double, score: Swift.Int)
  @objc deinit
  @objc override dynamic public init()
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum RDCRandomTag : Swift.Int {
  case one
  case two
  case three
  case four
  case five
  case six
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public func rdcGetRandomInt(min: Swift.Int, max: Swift.Int, _ tag: Ryu.RDCRandomTag = .one) -> Swift.Int
public func rdcGetRandomFloat(min: Swift.Float, max: Swift.Float, _ tag: Ryu.RDCRandomTag = .one) -> Swift.Float
extension Array {
  public func rdcRandomElement(_ tag: Ryu.RDCRandomTag = .one) -> Any
}
public enum RDCBackgroundStyle {
  case light, regular, dark
  public static func == (a: Ryu.RDCBackgroundStyle, b: Ryu.RDCBackgroundStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum RDCGradientDirection : Swift.String, Swift.Decodable {
  case leftToRight
  case rightToLeft
  case TopToBottom
  case BottomToTop
  case TopLeftToBottomRight
  case BottomRightToTopLeft
  case TopRightToBottomLeft
  case BottomLeftToTopRight
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public func rdcExitMatch(_ viewController: UIKit.UIViewController)
public var isRyuMatch: Swift.Bool {
  get
}
public var rdcGameType: Swift.String {
  get
}
public var willShowPrematchOverlay: Swift.Bool {
  get
}
public var isRyuTutorial: Swift.Bool
public enum RDCSubmissionType : Swift.String {
  case highestWins
  case lowestWins
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public func rdcSubmitScore(_ viewController: UIKit.UIViewController, score: Swift.Int, _ customSubmittingView: UIKit.UIView? = nil, labelText: Swift.String? = nil, submissionType: Ryu.RDCSubmissionType = .highestWins, completion: ((Swift.Bool) -> Swift.Void)? = nil)
public func getPearlStoreItems() -> Swift.String
public func hasPurchased(itemId: Swift.String) -> Swift.Bool
public func itemName(itemId: Swift.String) -> Swift.String
public func itemCost(itemId: Swift.String) -> Swift.Int
public enum RDCPauseButtonPlacement {
  case topLeft, topCenter, topRight, middleRight, bottomRight, bottomCenter, bottomLeft, middleLeft
  public static func == (a: Ryu.RDCPauseButtonPlacement, b: Ryu.RDCPauseButtonPlacement) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol GameViewControllerPauseDelegate : AnyObject {
  func pauseMenuWillDisplay()
  func pauseMenuWillHide()
  func submitScoreFromPauseMenu()
}
public func pauseRDCTimer(_ viewController: UIKit.UIViewController, duration: Foundation.TimeInterval, elapsed: Foundation.TimeInterval)
public func resumeRDCTimer(_ viewController: UIKit.UIViewController, duration: Foundation.TimeInterval, elapsed: Foundation.TimeInterval)
public func addRDCTimer(_ viewController: UIKit.UIViewController, withPlacement placement: Ryu.RDCPauseButtonPlacement, color: UIKit.UIColor, duration: Foundation.TimeInterval, elapsed: Foundation.TimeInterval, shouldShowHours: Swift.Bool)
public func addPauseButton(_ viewController: UIKit.UIViewController, withPlacement placement: Ryu.RDCPauseButtonPlacement, color: UIKit.UIColor, delay: Swift.Int?)
public var isRyuMusicEnabled: Swift.Bool
public var isRyuSoundEffectsEnabled: Swift.Bool
@objc public protocol RyuAttributionDelegate : AppsFlyerLib.AppsFlyerLibDelegate {
  @objc override dynamic func onConversionDataSuccess(_ conversionInfo: [Swift.AnyHashable : Any])
  @objc override dynamic func onConversionDataFail(_ error: Swift.Error)
  @objc optional override dynamic func onAppOpenAttribution(_ attributionData: [Swift.AnyHashable : Any])
  @objc optional override dynamic func onAppOpenAttributionFailure(_ error: Swift.Error)
}
public func rdcOnConversionDataSuccess(_ conversionInfo: [Swift.AnyHashable : Any])
public func rdcOnConversionDataFail(_ error: Swift.Error)
public func rdcLogStartTutorial()
public func rdcLogEndTutorial()
public func rdcDidGameStart(_ viewController: UIKit.UIViewController, selector: ObjectiveC.Selector?)
public protocol SocketEnginePollable : Ryu.SocketEngineSpec {
  var invalidated: Swift.Bool { get }
  var postWait: [Ryu.Post] { get set }
  var session: Foundation.URLSession? { get }
  var waitingForPoll: Swift.Bool { get set }
  var waitingForPost: Swift.Bool { get set }
  func doPoll()
  func sendPollMessage(_ message: Swift.String, withType type: Ryu.SocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())?)
  func stopPolling()
}
extension SocketEnginePollable {
  public func doPoll()
  public func sendPollMessage(_ message: Swift.String, withType type: Ryu.SocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())? = nil)
  public func stopPolling()
}
public struct SocketPacket : Swift.CustomStringConvertible {
  public let nsp: Swift.String
  public let id: Swift.Int
  public let type: Ryu.SocketPacket.PacketType
  public var binary: [Foundation.Data] {
    get
  }
  public var data: [Any] {
    get
  }
  public var args: [Any] {
    get
  }
  public var description: Swift.String {
    get
  }
  public var event: Swift.String {
    get
  }
  public var packetString: Swift.String {
    get
  }
}
extension SocketPacket {
  public enum PacketType : Swift.Int {
    case connect
    case disconnect
    case event
    case ack
    case error
    case binaryEvent
    case binaryAck
    public var isBinary: Swift.Bool {
      get
    }
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
}
@objc @_hasMissingDesignatedInitializers final public class SocketAnyEvent : ObjectiveC.NSObject {
  @objc final public let event: Swift.String
  @objc final public let items: [Any]?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol SocketParsable : AnyObject {
  func parseBinaryData(_ data: Foundation.Data) -> Ryu.SocketPacket?
  func parseSocketMessage(_ message: Swift.String) -> Ryu.SocketPacket?
}
public enum SocketParsableError : Swift.Error {
  case invalidDataArray
  case invalidPacket
  case invalidPacketType
  public static func == (a: Ryu.SocketParsableError, b: Ryu.SocketParsableError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol SocketDataBufferable : AnyObject {
  var waitingPackets: [Ryu.SocketPacket] { get set }
}
extension SocketParsable where Self : Ryu.SocketDataBufferable, Self : Ryu.SocketManagerSpec {
  public func parseSocketMessage(_ message: Swift.String) -> Ryu.SocketPacket?
  public func parseBinaryData(_ data: Foundation.Data) -> Ryu.SocketPacket?
}
@objc public enum SocketEnginePacketType : Swift.Int {
  case open
  case close
  case ping
  case pong
  case message
  case upgrade
  case noop
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
  public init?(rawValue: Swift.Int)
}
@objc open class SocketManager : ObjectiveC.NSObject, Ryu.SocketManagerSpec, Ryu.SocketParsable, Ryu.SocketDataBufferable, Ryu.ConfigSettable {
  @objc public var defaultSocket: Ryu.SocketIOClient {
    @objc get
  }
  @objc final public let socketURL: Foundation.URL
  public var config: Ryu.SocketIOClientConfiguration {
    get
    set
  }
  @objc public var engine: Ryu.SocketEngineSpec?
  @objc public var forceNew: Swift.Bool
  @objc public var handleQueue: Dispatch.DispatchQueue
  @objc public var nsps: [Swift.String : Ryu.SocketIOClient]
  @objc public var reconnects: Swift.Bool
  @objc public var reconnectWait: Swift.Int
  @objc public var reconnectWaitMax: Swift.Int
  @objc public var randomizationFactor: Swift.Double
  @objc public var status: Ryu.SocketIOStatus {
    @objc get
  }
  public var waitingPackets: [Ryu.SocketPacket]
  public init(socketURL: Foundation.URL, config: Ryu.SocketIOClientConfiguration = [])
  @objc convenience public init(socketURL: Foundation.URL, config: [Swift.String : Any]?)
  @objc deinit
  @objc open func connect()
  @objc open func connectSocket(_ socket: Ryu.SocketIOClient)
  @objc open func didDisconnect(reason: Swift.String)
  @objc open func disconnect()
  @objc open func disconnectSocket(_ socket: Ryu.SocketIOClient)
  @objc open func disconnectSocket(forNamespace nsp: Swift.String)
  open func emitAll(clientEvent event: Ryu.SocketClientEvent, data: [Any])
  open func emitAll(_ event: Swift.String, _ items: Ryu.SocketData...)
  @objc open func emitAll(_ event: Swift.String, withItems items: [Any])
  @objc open func engineDidClose(reason: Swift.String)
  @objc open func engineDidError(reason: Swift.String)
  @objc open func engineDidOpen(reason: Swift.String)
  @objc open func engineDidReceivePong()
  @objc open func engineDidSendPing()
  @objc open func engineDidWebsocketUpgrade(headers: [Swift.String : Swift.String])
  @objc open func parseEngineMessage(_ msg: Swift.String)
  @objc open func parseEngineBinaryData(_ data: Foundation.Data)
  @objc open func reconnect()
  @discardableResult
  @objc open func removeSocket(_ socket: Ryu.SocketIOClient) -> Ryu.SocketIOClient?
  open func setConfigs(_ config: Ryu.SocketIOClientConfiguration)
  @objc open func socket(forNamespace nsp: Swift.String) -> Ryu.SocketIOClient
  @objc override dynamic public init()
}
public protocol SocketEngineWebsocket : Ryu.SocketEngineSpec {
  func sendWebSocketMessage(_ str: Swift.String, withType type: Ryu.SocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())?)
}
extension SocketEngineWebsocket {
  public func sendWebSocketMessage(_ str: Swift.String, withType type: Ryu.SocketEnginePacketType, withData datas: [Foundation.Data], completion: (() -> ())?)
}
@_hasMissingDesignatedInitializers public class FacebookAnalyticsManager {
  public func logEvent(name: Swift.String, description: Swift.String)
  @objc deinit
}
extension UINavigationController : UIKit.UIGestureRecognizerDelegate {
  @objc override dynamic open func viewDidLoad()
  @objc dynamic public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
@objc public protocol SocketEngineClient {
  @objc func engineDidError(reason: Swift.String)
  @objc func engineDidClose(reason: Swift.String)
  @objc func engineDidOpen(reason: Swift.String)
  @objc func engineDidReceivePong()
  @objc func engineDidSendPing()
  @objc func parseEngineMessage(_ msg: Swift.String)
  @objc func parseEngineBinaryData(_ data: Foundation.Data)
  @objc func engineDidWebsocketUpgrade(headers: [Swift.String : Swift.String])
}
@objc @_hasMissingDesignatedInitializers final public class SocketRawView : ObjectiveC.NSObject {
  final public func emit(_ event: Swift.String, _ items: Ryu.SocketData...)
  @objc final public func emit(_ event: Swift.String, with items: [Any])
  final public func emitWithAck(_ event: Swift.String, _ items: Ryu.SocketData...) -> Ryu.OnAckCallback
  @objc final public func emitWithAck(_ event: Swift.String, with items: [Any]) -> Ryu.OnAckCallback
  @objc override dynamic public init()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class SocketRawAckView : ObjectiveC.NSObject {
  final public func with(_ items: Ryu.SocketData...)
  @objc final public func with(_ items: [Any])
  @objc override dynamic public init()
  @objc deinit
}
@objc open class SocketEngine : ObjectiveC.NSObject, Foundation.URLSessionDelegate, Ryu.SocketEnginePollable, Ryu.SocketEngineWebsocket, Ryu.ConfigSettable {
  @objc final public let engineQueue: Dispatch.DispatchQueue
  @objc public var connectParams: [Swift.String : Any]? {
    @objc get
    @objc set
  }
  @objc public var extraHeaders: [Swift.String : Swift.String]?
  public var postWait: [Ryu.Post]
  public var waitingForPoll: Swift.Bool
  public var waitingForPost: Swift.Bool
  @objc public var closed: Swift.Bool {
    get
  }
  @objc public var compress: Swift.Bool {
    get
  }
  @objc public var connected: Swift.Bool {
    get
  }
  @objc public var cookies: [Foundation.HTTPCookie]? {
    get
  }
  @objc public var fastUpgrade: Swift.Bool {
    get
  }
  @objc public var forcePolling: Swift.Bool {
    get
  }
  @objc public var forceWebsockets: Swift.Bool {
    get
  }
  public var invalidated: Swift.Bool {
    get
  }
  @objc public var polling: Swift.Bool {
    get
  }
  @objc public var probing: Swift.Bool {
    get
  }
  public var session: Foundation.URLSession? {
    get
  }
  @objc public var sid: Swift.String {
    get
  }
  @objc public var socketPath: Swift.String {
    get
  }
  @objc public var urlPolling: Foundation.URL {
    get
  }
  @objc public var urlWebSocket: Foundation.URL {
    get
  }
  @available(*, deprecated, message: "No longer needed, if we're not polling, then we must be doing websockets")
  @objc public var websocket: Swift.Bool {
    get
  }
  @objc public var ws: Ryu.WebSocket? {
    get
  }
  @objc weak public var client: Ryu.SocketEngineClient?
  public init(client: Ryu.SocketEngineClient, url: Foundation.URL, config: Ryu.SocketIOClientConfiguration)
  @objc required convenience public init(client: Ryu.SocketEngineClient, url: Foundation.URL, options: [Swift.String : Any]?)
  @objc deinit
  @objc open func connect()
  @objc open func didError(reason: Swift.String)
  @objc open func disconnect(reason: Swift.String)
  @objc open func doFastUpgrade()
  @objc open func flushWaitingForPostToWebSocket()
  @objc open func parseEngineData(_ data: Foundation.Data)
  @objc open func parseEngineMessage(_ message: Swift.String)
  open func setConfigs(_ config: Ryu.SocketIOClientConfiguration)
  @objc open func write(_ msg: Swift.String, withType type: Ryu.SocketEnginePacketType, withData data: [Foundation.Data], completion: (() -> ())? = nil)
  @objc override dynamic public init()
}
extension SocketEngine {
  public func URLSession(session: Foundation.URLSession, didBecomeInvalidWithError error: Foundation.NSError?)
}
public protocol MessageCellDelegate : AnyObject {
  func messageTapped(indexPath: Foundation.IndexPath)
}
public protocol SSLTrustValidator {
  func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
open class SSLCert {
  public init(data: Foundation.Data)
  public init(key: Security.SecKey)
  @objc deinit
}
open class StarscreamSSLSecurity : Ryu.SSLTrustValidator {
  public var validatedDN: Swift.Bool
  public var validateEntireChain: Swift.Bool
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [Ryu.SSLCert], usePublicKeys: Swift.Bool)
  open func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  public func extractPublicKey(_ data: Foundation.Data) -> Security.SecKey?
  public func extractPublicKey(_ cert: Security.SecCertificate, policy: Security.SecPolicy) -> Security.SecKey?
  public func certificateChain(_ trust: Security.SecTrust) -> [Foundation.Data]
  public func publicKeyChain(_ trust: Security.SecTrust) -> [Security.SecKey]
  @objc deinit
}
public struct SocketEventHandler {
  public let event: Swift.String
  public let id: Foundation.UUID
  public let callback: Ryu.NormalCallback
  public func executeCallback(with items: [Any], withAck ack: Swift.Int, withSocket socket: Ryu.SocketIOClient)
}
public protocol SocketLogger : AnyObject {
  var log: Swift.Bool { get set }
  func log(_ message: @autoclosure () -> Swift.String, type: Swift.String)
  func error(_ message: @autoclosure () -> Swift.String, type: Swift.String)
}
extension SocketLogger {
  public func log(_ message: @autoclosure () -> Swift.String, type: Swift.String)
  public func error(_ message: @autoclosure () -> Swift.String, type: Swift.String)
}
public enum SocketAckStatus : Swift.String {
  case noAck
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@objc @_hasMissingDesignatedInitializers open class SSLSecurity : ObjectiveC.NSObject {
  final public let security: Ryu.StarscreamSSLSecurity
  @objc convenience public init(usePublicKeys: Swift.Bool = true)
  convenience public init(certs: [Ryu.SSLCert], usePublicKeys: Swift.Bool)
  public func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
public struct RDCApplePayConfig : Swift.Codable {
  public var devId: Swift.String?
  public var prodId: Swift.String?
  public init(devId: Swift.String?, prodId: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct OfflineOption : Swift.Equatable {
  public var id: Swift.String
  public var title: Swift.String
  public var gameMode: Swift.String
  public var rules: [Swift.String]
  public var boxColor: Swift.String
  public var description: Swift.String
  public init(id: Swift.String, title: Swift.String, gameMode: Swift.String, rules: [Swift.String], boxColor: Swift.String, textColor: Swift.String, buttonColor: Swift.String, buttonTextColor: Swift.String, description: Swift.String)
  public static func == (a: Ryu.OfflineOption, b: Ryu.OfflineOption) -> Swift.Bool
}
public var currentScreenState: Ryu.ScreenNavigationState
public enum ScreenNavigationState {
  case Ryu
  case Game
  case Loading
  public static func == (a: Ryu.ScreenNavigationState, b: Ryu.ScreenNavigationState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public func pausedTappedOnGame(_ gameViewController: UIKit.UIViewController)
public struct SSLClientCertificateError : Foundation.LocalizedError {
  public var errorDescription: Swift.String?
}
public class SSLClientCertificate {
  convenience public init(pkcs12Path: Swift.String, password: Swift.String) throws
  public init(identity: Security.SecIdentity, identityCertificate: Security.SecCertificate)
  convenience public init(pkcs12Url: Foundation.URL, password: Swift.String) throws
  public init(pkcs12Url: Foundation.URL, importOptions: CoreFoundation.CFDictionary) throws
  @objc deinit
}
public let WebsocketDidConnectNotification: Swift.String
public let WebsocketDidDisconnectNotification: Swift.String
public let WebsocketDisconnectionErrorKeyName: Swift.String
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public typealias RawValue = Swift.UInt16
  public init?(rawValue: Swift.UInt16)
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum ErrorType : Swift.Error {
  case outputStreamWriteError
  case compressionError
  case invalidSSLError
  case writeTimeoutError
  case protocolError
  case upgradeError
  case closeError
  public static func == (a: Ryu.ErrorType, b: Ryu.ErrorType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct WSError : Swift.Error {
  public let type: Ryu.ErrorType
  public let message: Swift.String
  public let code: Swift.Int
}
public protocol WebSocketClient : AnyObject {
  var delegate: Ryu.WebSocketDelegate? { get set }
  var pongDelegate: Ryu.WebSocketPongDelegate? { get set }
  var disableSSLCertValidation: Swift.Bool { get set }
  var overrideTrustHostname: Swift.Bool { get set }
  var desiredTrustHostname: Swift.String? { get set }
  var sslClientCertificate: Ryu.SSLClientCertificate? { get set }
  var security: Ryu.SSLTrustValidator? { get set }
  var enabledSSLCipherSuites: [Security.SSLCipherSuite]? { get set }
  var isConnected: Swift.Bool { get }
  func connect()
  func disconnect(forceTimeout: Foundation.TimeInterval?, closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public struct SSLSettings {
  public let useSSL: Swift.Bool
  public let disableCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public let sslClientCertificate: Ryu.SSLClientCertificate?
  public let cipherSuites: [Security.SSLCipherSuite]?
}
public protocol WSStreamDelegate : AnyObject {
  func newBytesInStream()
  func streamDidError(error: Swift.Error?)
}
public protocol WSStream {
  var delegate: Ryu.WSStreamDelegate? { get set }
  func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: Ryu.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  func write(data: Foundation.Data) -> Swift.Int
  func read() -> Foundation.Data?
  func cleanup()
  func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
}
@objc @_inheritsConvenienceInitializers open class FoundationStream : ObjectiveC.NSObject, Ryu.WSStream, Foundation.StreamDelegate {
  weak public var delegate: Ryu.WSStreamDelegate?
  public var enableSOCKSProxy: Swift.Bool
  public func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: Ryu.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  public func write(data: Foundation.Data) -> Swift.Int
  public func read() -> Foundation.Data?
  public func cleanup()
  public func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc deinit
  @objc override dynamic public init()
}
public protocol WebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: Ryu.WebSocketClient)
  func websocketDidDisconnect(socket: Ryu.WebSocketClient, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: Ryu.WebSocketClient, text: Swift.String)
  func websocketDidReceiveData(socket: Ryu.WebSocketClient, data: Foundation.Data)
}
public protocol WebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: Ryu.WebSocketClient, data: Foundation.Data?)
}
public protocol WebSocketAdvancedDelegate : AnyObject {
  func websocketDidConnect(socket: Ryu.WebSocket)
  func websocketDidDisconnect(socket: Ryu.WebSocket, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: Ryu.WebSocket, text: Swift.String, response: Ryu.WebSocket.WSResponse)
  func websocketDidReceiveData(socket: Ryu.WebSocket, data: Foundation.Data, response: Ryu.WebSocket.WSResponse)
  func websocketHttpUpgrade(socket: Ryu.WebSocket, request: Swift.String)
  func websocketHttpUpgrade(socket: Ryu.WebSocket, response: Swift.String)
}
@objc open class WebSocket : ObjectiveC.NSObject, Foundation.StreamDelegate, Ryu.WebSocketClient, Ryu.WSStreamDelegate {
  public enum OpCode : Swift.UInt8 {
    case continueFrame
    case textFrame
    case binaryFrame
    case connectionClose
    case ping
    case pong
    public typealias RawValue = Swift.UInt8
    public init?(rawValue: Swift.UInt8)
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let ErrorDomain: Swift.String
  public var callbackQueue: Dispatch.DispatchQueue
  @_hasMissingDesignatedInitializers public class WSResponse {
    public var code: Ryu.WebSocket.OpCode
    public var frameCount: Swift.Int
    public var buffer: Foundation.NSMutableData?
    final public let firstFrame: Foundation.Date
    @objc deinit
  }
  weak public var delegate: Ryu.WebSocketDelegate?
  weak public var advancedDelegate: Ryu.WebSocketAdvancedDelegate?
  weak public var pongDelegate: Ryu.WebSocketPongDelegate?
  public var onConnect: (() -> Swift.Void)?
  public var onDisconnect: ((Swift.Error?) -> Swift.Void)?
  public var onText: ((Swift.String) -> Swift.Void)?
  public var onData: ((Foundation.Data) -> Swift.Void)?
  public var onPong: ((Foundation.Data?) -> Swift.Void)?
  public var onHttpResponseHeaders: (([Swift.String : Swift.String]) -> Swift.Void)?
  public var disableSSLCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public var sslClientCertificate: Ryu.SSLClientCertificate?
  public var enableCompression: Swift.Bool
  public var security: Ryu.SSLTrustValidator?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  public var isConnected: Swift.Bool {
    get
  }
  public var request: Foundation.URLRequest
  public var currentURL: Foundation.URL {
    get
  }
  public var respondToPingWithPong: Swift.Bool
  public init(request: Foundation.URLRequest, protocols: [Swift.String]? = nil, stream: Ryu.WSStream = FoundationStream())
  convenience public init(url: Foundation.URL, protocols: [Swift.String]? = nil)
  convenience public init(url: Foundation.URL, writeQueueQOS: Foundation.QualityOfService, protocols: [Swift.String]? = nil)
  open func connect()
  open func disconnect(forceTimeout: Foundation.TimeInterval? = nil, closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  open func write(string: Swift.String, completion: (() -> ())? = nil)
  open func write(data: Foundation.Data, completion: (() -> ())? = nil)
  open func write(ping: Foundation.Data, completion: (() -> ())? = nil)
  open func write(pong: Foundation.Data, completion: (() -> ())? = nil)
  public func newBytesInStream()
  public func streamDidError(error: Swift.Error?)
  @objc deinit
  @objc override dynamic public init()
}
extension Ryu.SocketIOClientOption : Swift.Equatable {}
extension Ryu.SocketIOClientOption : Swift.CustomStringConvertible {}
extension Ryu.SocketIOStatus : Swift.Equatable {}
extension Ryu.SocketIOStatus : Swift.Hashable {}
extension Ryu.SocketIOStatus : Swift.RawRepresentable {}
extension Ryu.SocketClientEvent : Swift.Equatable {}
extension Ryu.SocketClientEvent : Swift.Hashable {}
extension Ryu.SocketClientEvent : Swift.RawRepresentable {}
extension Ryu.RDCError : Swift.Equatable {}
extension Ryu.RDCError : Swift.Hashable {}
extension Ryu.RDCBackgroundAnimation : Swift.Equatable {}
extension Ryu.RDCBackgroundAnimation : Swift.Hashable {}
extension Ryu.SkipTutorialButtonPlacement : Swift.Equatable {}
extension Ryu.SkipTutorialButtonPlacement : Swift.Hashable {}
extension Ryu.RDCRandomTag : Swift.Equatable {}
extension Ryu.RDCRandomTag : Swift.Hashable {}
extension Ryu.RDCRandomTag : Swift.RawRepresentable {}
extension Ryu.RDCBackgroundStyle : Swift.Equatable {}
extension Ryu.RDCBackgroundStyle : Swift.Hashable {}
extension Ryu.RDCGradientDirection : Swift.Equatable {}
extension Ryu.RDCGradientDirection : Swift.Hashable {}
extension Ryu.RDCGradientDirection : Swift.RawRepresentable {}
extension Ryu.RDCSubmissionType : Swift.Equatable {}
extension Ryu.RDCSubmissionType : Swift.Hashable {}
extension Ryu.RDCSubmissionType : Swift.RawRepresentable {}
extension Ryu.RDCPauseButtonPlacement : Swift.Equatable {}
extension Ryu.RDCPauseButtonPlacement : Swift.Hashable {}
extension Ryu.SocketPacket.PacketType : Swift.Equatable {}
extension Ryu.SocketPacket.PacketType : Swift.Hashable {}
extension Ryu.SocketPacket.PacketType : Swift.RawRepresentable {}
extension Ryu.SocketParsableError : Swift.Equatable {}
extension Ryu.SocketParsableError : Swift.Hashable {}
extension Ryu.SocketEnginePacketType : Swift.Equatable {}
extension Ryu.SocketEnginePacketType : Swift.Hashable {}
extension Ryu.SocketEnginePacketType : Swift.RawRepresentable {}
extension Ryu.SocketAckStatus : Swift.Equatable {}
extension Ryu.SocketAckStatus : Swift.Hashable {}
extension Ryu.SocketAckStatus : Swift.RawRepresentable {}
extension Ryu.ScreenNavigationState : Swift.Equatable {}
extension Ryu.ScreenNavigationState : Swift.Hashable {}
extension Ryu.CloseCode : Swift.Equatable {}
extension Ryu.CloseCode : Swift.Hashable {}
extension Ryu.CloseCode : Swift.RawRepresentable {}
extension Ryu.ErrorType : Swift.Equatable {}
extension Ryu.ErrorType : Swift.Hashable {}
extension Ryu.WebSocket.OpCode : Swift.Equatable {}
extension Ryu.WebSocket.OpCode : Swift.Hashable {}
extension Ryu.WebSocket.OpCode : Swift.RawRepresentable {}
